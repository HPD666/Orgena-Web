<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Orgena Workspace</title>
  <style>
    body { background: #222733; color: #eee; font-family: 'Segoe UI', Arial, sans-serif; margin: 0; padding: 0; }
    .container { max-width: 900px; margin: 40px auto; background: #181a20; border-radius: 10px; box-shadow: 0 0 10px #0007; padding: 32px 36px; }
    h1, h2 { color: #97c1ff; }
    pre, textarea { background: #232733; color: #fff; border: none; border-radius: 4px; padding: 10px; font-size: 1em; }
    textarea { width: 100%; min-height: 420px; font-family: 'Fira Mono', 'Consolas', monospace; margin-bottom: 1em; font-size: 1.08em; }
    button { background: #3c8dde; color: #fff; border: none; border-radius: 5px; padding: 10px 24px; font-size: 1.1em; cursor: pointer; margin-bottom: 20px; }
    button:hover { background: #2767a6; }
    #output { background: #1a1d22; color: #9afc9a; border-radius: 4px; padding: 12px; min-height: 2em; white-space: pre-wrap; font-size: 1em; }
    a { color: #7ea6ff; }
    hr { border: none; border-bottom: 1px solid #333; margin: 32px 0; }
    #promptInput { display: none; }
    #orgenaElements { margin-top: 24px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Orgena Workspace</h1>
    <form onsubmit="runOrgena(); return false;">
      <b>Code:</b>
      <textarea id="code" spellcheck="false">
// Try Orgena's new HTML features!
Create Element button as myBtn
Set text of myBtn to "Say Hello!"
Add myBtn to page
On click of myBtn, run
  Say "Hello from Orgena and HTML!"
end
      </textarea><br>
      <button type="submit">Run Orgena</button>
    </form>
    <input id="promptInput" type="text" placeholder="Type your answer and press Enter...">
    <div id="output"></div>
    <div id="orgenaElements"></div>
    <hr>
    <div style="font-size:0.95em; color:#aaa;">
      Orgena is open source! See <a href="https://github.com/HPD666/Orgena-Web" target="_blank">GitHub</a>.
    </div>
  </div>
  <script>
    function runOrgena() {
      const code = document.getElementById('code').value;
      const lines = code.replace(/\r\n/g, '\n').split('\n');
      let vars = Object.create(null);
      let output = '';
      let functions = {};
      let pc = 0;
      let awaitingInput = false;
      let inputVarName = '';
      let inputCallback = null;
      let orgenaElements = Object.create(null); // For HTML elements
      let eventBlocks = []; // For storing event handlers

      // Clear previous Orgena-created HTML
      document.getElementById('orgenaElements').innerHTML = '';

      function evalExpr(expr) {
        expr = expr.trim();
        if (/^"([^"]*)"$/i.test(expr)) return expr.replace(/^"|"$/g, "");
        if (/^sqrt of (.+)$/i.test(expr)) return Math.sqrt(evalExpr(expr.match(/^sqrt of (.+)$/i)[1]));
        if (/^abs of (.+)$/i.test(expr)) return Math.abs(evalExpr(expr.match(/^abs of (.+)$/i)[1]));
        if (/^Random between (.+) and (.+)$/i.test(expr)) {
          let m = expr.match(/^Random between (.+) and (.+)$/i);
          let min = parseFloat(evalExpr(m[1])), max = parseFloat(evalExpr(m[2]));
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        if (/^floor (.+)$/i.test(expr)) return Math.floor(evalExpr(expr.match(/^floor (.+)$/i)[1]));
        if (/^ceil (.+)$/i.test(expr)) return Math.ceil(evalExpr(expr.match(/^ceil (.+)$/i)[1]));
        if (/^round (.+)$/i.test(expr)) return Math.round(evalExpr(expr.match(/^round (.+)$/i)[1]));
        if (/^power (.+) (.+)$/i.test(expr)) { let m=expr.match(/^power (.+) (.+)$/i); return Math.pow(evalExpr(m[1]),evalExpr(m[2])); }
        if (/^modulo (.+) (.+)$/i.test(expr)) { let m=expr.match(/^modulo (.+) (.+)$/i); return evalExpr(m[1])%evalExpr(m[2]); }
        if (/^log (.+)$/i.test(expr)) return Math.log10(evalExpr(expr.match(/^log (.+)$/i)[1]));
        if (/^exp (.+)$/i.test(expr)) return Math.exp(evalExpr(expr.match(/^exp (.+)$/i)[1]));
        if (/^sin (.+)$/i.test(expr)) return Math.sin(evalExpr(expr.match(/^sin (.+)$/i)[1]));
        if (/^cos (.+)$/i.test(expr)) return Math.cos(evalExpr(expr.match(/^cos (.+)$/i)[1]));
        if (/^tan (.+)$/i.test(expr)) return Math.tan(evalExpr(expr.match(/^tan (.+)$/i)[1]));
        if (/^Now$/i.test(expr)) return new Date().toLocaleString();
        if (/^current time$/i.test(expr)) return new Date().toLocaleTimeString();
        if (/^current date$/i.test(expr)) return new Date().toLocaleDateString();
        if (/^([a-zA-Z_]\w*) at (\d+)$/i.test(expr)) {
          let m = expr.match(/^([a-zA-Z_]\w*) at (\d+)$/i);
          let arr = vars[m[1]];
          let idx = parseInt(m[2]) - 1;
          if (Array.isArray(arr) && idx >= 0 && idx < arr.length) return arr[idx];
          else return '';
        }
        if (/^Uppercase (.+)$/i.test(expr)) { let s=evalExpr(expr.match(/^Uppercase (.+)$/i)[1]); return String(s).toUpperCase();}
        if (/^Lowercase (.+)$/i.test(expr)) { let s=evalExpr(expr.match(/^Lowercase (.+)$/i)[1]); return String(s).toLowerCase();}
        if (/^Substring (.+) from (\d+) to (\d+)$/i.test(expr)) {
          let m=expr.match(/^Substring (.+) from (\d+) to (\d+)$/i);
          let s=evalExpr(m[1]), a=parseInt(m[2])-1, b=parseInt(m[3]);
          return String(s).substring(a,b);
        }
        if (/^Contains (.+) in (.+)$/i.test(expr)) {
          let m=expr.match(/^Contains (.+) in (.+)$/i); let a=evalExpr(m[1]), b=evalExpr(m[2]);
          return String(b).includes(String(a));
        }
        if (/^Repeat (.+) (\d+) times$/i.test(expr)) {
          let m=expr.match(/^Repeat (.+) (\d+) times$/i); let s=evalExpr(m[1]), n=parseInt(m[2]);
          return String(s).repeat(n);
        }
        if (/^Trim (.+)$/i.test(expr)) { let s=evalExpr(expr.match(/^Trim (.+)$/i)[1]); return String(s).trim();}
        if (/^Pad (.+) to (\d+) with (.+)$/i.test(expr)) {
          let m=expr.match(/^Pad (.+) to (\d+) with (.+)$/i); let s=evalExpr(m[1]), n=parseInt(m[2]), chr=evalExpr(m[3]);
          return String(s).padStart(n,chr);
        }
        if (/^Starts with (.+) in (.+)$/i.test(expr)) {
          let m=expr.match(/^Starts with (.+) in (.+)$/i); let a=evalExpr(m[1]), b=evalExpr(m[2]);
          return String(b).startsWith(String(a));
        }
        if (/^Ends with (.+) in (.+)$/i.test(expr)) {
          let m=expr.match(/^Ends with (.+) in (.+)$/i); let a=evalExpr(m[1]), b=evalExpr(m[2]);
          return String(b).endsWith(String(a));
        }
        if (/^Random choice from ([a-zA-Z_]\w*)$/i.test(expr)) {
          let m = expr.match(/^Random choice from ([a-zA-Z_]\w*)$/i);
          let arr = vars[m[1]];
          if (Array.isArray(arr) && arr.length>0) return arr[Math.floor(Math.random()*arr.length)];
          return "";
        }
        expr = expr.replace(/ plus /gi, ' + ')
                   .replace(/ minus /gi, ' - ')
                   .replace(/ times /gi, ' * ')
                   .replace(/ multiplied by /gi, ' * ')
                   .replace(/ divided by /gi, ' / ')
                   .replace(/ mod /gi, ' % ');
        expr = expr.replace(/\b[a-zA-Z_]\w*\b/g, function(name){
          if (Object.prototype.hasOwnProperty.call(vars, name)) return vars[name];
          return name;
        });
        try { return eval(expr); }
        catch { return expr; }
      }

      function parseCondition(cond) {
        cond = cond.trim();
        let m = cond.match(/(.+) is (greater than|less than|equal to|equals|not equal to|not equals) (.+)/i);
        if (!m) return false;
        let left = evalExpr(m[1]);
        let op = m[2].toLowerCase();
        let right = evalExpr(m[3]);
        if (op === 'greater than') return left > right;
        if (op === 'less than') return left < right;
        if (op === 'equal to' || op === 'equals') return left == right;
        if (op === 'not equal to' || op === 'not equals') return left != right;
        return false;
      }

      function runBlock(start) {
        let block = [];
        let indent = lines[start].match(/^(\s*)/)[1].length;
        let i = start;
        for (; i < lines.length; i++) {
          let line = lines[i];
          if (line.trim().toLowerCase() === 'end') break;
          if (i !== start && line.match(/^(\s*)/)[1].length <= indent) break;
          block.push(line.replace(new RegExp(`^ {0,${indent}}`), ''));
        }
        return { block, next: i+1 };
      }

      function execBlock(blockLines, localVars={}) {
        let oldVars = Object.assign({}, vars);
        Object.assign(vars, localVars);
        for (let l = 0; l < blockLines.length; l++) {
          execLine(blockLines[l]);
        }
        vars = oldVars;
      }

      function execLine(line) {
        line = line.trim();
        if (line === '' || line.startsWith('//') || line.startsWith('#')) return;

        // --- HTML Extension Start ---

        // Create Element <type> as <name>
        if (/^Create Element ([a-zA-Z0-9]+) as ([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Create Element ([a-zA-Z0-9]+) as ([a-zA-Z_]\w*)$/i);
          let tag = m[1], name = m[2];
          let el = document.createElement(tag);
          el.style.margin = "6px";
          orgenaElements[name] = el;
          return;
        }

        // Set text of <name> to <value>
        if (/^Set text of ([a-zA-Z_]\w*) to (.+)$/i.test(line)) {
          let m = line.match(/^Set text of ([a-zA-Z_]\w*) to (.+)$/i);
          let name = m[1], val = evalExpr(m[2]);
          if (orgenaElements[name]) orgenaElements[name].textContent = val;
          return;
        }

        // Set attribute <attr> of <name> to <value>
        if (/^Set attribute ([a-zA-Z0-9\-_]+) of ([a-zA-Z_]\w*) to (.+)$/i.test(line)) {
          let m = line.match(/^Set attribute ([a-zA-Z0-9\-_]+) of ([a-zA-Z_]\w*) to (.+)$/i);
          let attr = m[1], name = m[2], val = evalExpr(m[3]);
          if (orgenaElements[name]) orgenaElements[name].setAttribute(attr, val);
          return;
        }

        // Set style of <name> to <css>
        if (/^Set style of ([a-zA-Z_]\w*) to (.+)$/i.test(line)) {
          let m = line.match(/^Set style of ([a-zA-Z_]\w*) to (.+)$/i);
          let name = m[1], css = evalExpr(m[2]);
          if (orgenaElements[name]) orgenaElements[name].style.cssText += ";" + css;
          return;
        }

        // Add <name> to page
        if (/^Add ([a-zA-Z_]\w*) to page$/i.test(line)) {
          let m = line.match(/^Add ([a-zA-Z_]\w*) to page$/i);
          let name = m[1];
          if (orgenaElements[name]) document.getElementById('orgenaElements').appendChild(orgenaElements[name]);
          return;
        }

        // Remove <name> from page
        if (/^Remove ([a-zA-Z_]\w*) from page$/i.test(line)) {
          let m = line.match(/^Remove ([a-zA-Z_]\w*) from page$/i);
          let name = m[1];
          if (orgenaElements[name] && orgenaElements[name].parentElement) orgenaElements[name].parentElement.removeChild(orgenaElements[name]);
          return;
        }

        // Show <name>
        if (/^Show ([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Show ([a-zA-Z_]\w*)$/i);
          let name = m[1];
          if (orgenaElements[name]) orgenaElements[name].style.display = '';
          return;
        }

        // Hide <name>
        if (/^Hide ([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Hide ([a-zA-Z_]\w*)$/i);
          let name = m[1];
          if (orgenaElements[name]) orgenaElements[name].style.display = 'none';
          return;
        }

        // On click of <name>, run ... end
        if (/^On click of ([a-zA-Z_]\w*), run$/i.test(line)) {
          let m = line.match(/^On click of ([a-zA-Z_]\w*), run$/i);
          let name = m[1];
          let { block, next } = runBlock(pc);
          if (orgenaElements[name]) {
            orgenaElements[name].onclick = function() {
              try { execBlock(block); }
              catch(e) { if (e !== 'PAUSE_FOR_INPUT') throw e; }
              document.getElementById('output').textContent = output || '(no output)';
            }
          }
          pc = next - 1;
          return;
        }

        // --- HTML Extension End ---

        if (/^Say\s+(.+)/i.test(line)) {
          let expr = line.match(/^Say\s+(.+)/i)[1];
          output += evalExpr(expr) + '\n';
        }
        else if (/^Remember\s+([a-zA-Z_]\w*)\s+is\s+(.+)/i.test(line)) {
          let m = line.match(/^Remember\s+([a-zA-Z_]\w*)\s+is\s+(.+)/i);
          vars[m[1]] = evalExpr(m[2]);
        }
        else if (/^If\s+(.+?),\s*(.+)\s+else\s+(.+)$/i.test(line)) {
          let m = line.match(/^If\s+(.+?),\s*(.+)\s+else\s+(.+)$/i);
          if (parseCondition(m[1])) execLine(m[2]);
          else execLine(m[3]);
        }
        else if (/^If\s+(.+?),\s*(.+)$/i.test(line)) {
          let m = line.match(/^If\s+(.+?),\s*(.+)$/i);
          if (parseCondition(m[1])) execLine(m[2]);
        }
        else if (/^Repeat while\s+(.+?),?$/i.test(line)) {
          let m = line.match(/^Repeat while\s+(.+?),?$/i);
          let { block, next } = runBlock(pc);
          while (parseCondition(m[1])) {
            execBlock(block);
          }
          pc = next - 1;
        }
        else if (/^Define\s+([a-zA-Z_]\w*)\s+with\s+([a-zA-Z_, ]+),?$/i.test(line)) {
          let m = line.match(/^Define\s+([a-zA-Z_]\w*)\s+with\s+([a-zA-Z_, ]+),?$/i);
          let fname = m[1], params = m[2].split(',').map(s=>s.trim());
          let { block, next } = runBlock(pc);
          functions[fname] = { params, block };
          pc = next - 1;
        }
        else if (/^Call\s+([a-zA-Z_]\w*)\s+with\s+(.+)$/i.test(line)) {
          let m = line.match(/^Call\s+([a-zA-Z_]\w*)\s+with\s+(.+)$/i);
          let fname = m[1], args = m[2].split(',').map(s=>evalExpr(s.trim()));
          if (functions[fname]) {
            let localVars = {};
            functions[fname].params.forEach((p, i) => localVars[p] = args[i]);
            execBlock(functions[fname].block, localVars);
          }
        }
        else if (/^([a-zA-Z_]\w*)\s+is\s+(.+)/i.test(line)) {
          let m = line.match(/^([a-zA-Z_]\w*)\s+is\s+(.+)/i);
          vars[m[1]] = evalExpr(m[2]);
        }
        else if (/^Add\s+(.+)\s+to\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Add\s+(.+)\s+to\s+([a-zA-Z_]\w*)$/i);
          let value = evalExpr(m[1]);
          let listName = m[2];
          if (!Array.isArray(vars[listName])) vars[listName] = [];
          vars[listName].push(value);
        }
        else if (/^Remove\s+(.+)\s+from\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Remove\s+(.+)\s+from\s+([a-zA-Z_]\w*)$/i);
          let value = evalExpr(m[1]);
          let listName = m[2];
          if (Array.isArray(vars[listName])) {
            vars[listName] = vars[listName].filter(item => item != value);
          }
        }
        else if (/^Show\s+([a-zA-Z_]\w*)$/i.test(line)) {
          // If not a DOM element, treat as list show (original behavior)
          let m = line.match(/^Show\s+([a-zA-Z_]\w*)$/i);
          let listName = m[1];
          if (Array.isArray(vars[listName])) {
            output += listName + ': ' + vars[listName].join(', ') + '\n';
          } else if (!orgenaElements[listName]) {
            output += listName + ' is not a list\n';
          }
        }
        else if (/^Hide\s+([a-zA-Z_]\w*)$/i.test(line)) {
          // If not a DOM element, skip (original behavior)
        }
        else if (/^Clear\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Clear\s+([a-zA-Z_]\w*)$/i);
          let listName = m[1];
          if (Array.isArray(vars[listName])) vars[listName] = [];
        }
        else if (/^Count\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Count\s+([a-zA-Z_]\w*)$/i);
          let listName = m[1];
          if (Array.isArray(vars[listName])) {
            output += listName + ' count: ' + vars[listName].length + '\n';
          } else {
            output += listName + ' is not a list\n';
          }
        }
        else if (/^For each\s+([a-zA-Z_]\w*)\s+in\s+([a-zA-Z_]\w*),?$/i.test(line)) {
          let m = line.match(/^For each\s+([a-zA-Z_]\w*)\s+in\s+([a-zA-Z_]\w*),?$/i);
          let itemVar = m[1], listName = m[2];
          let { block, next } = runBlock(pc);
          if (Array.isArray(vars[listName])) {
            for (let v of vars[listName]) {
              let localVars = {};
              localVars[itemVar] = v;
              execBlock(block, localVars);
            }
          }
          pc = next - 1;
        }
        else if (/^Join\s+([a-zA-Z_]\w*)\s+with\s+(.+)$/i.test(line)) {
          let m = line.match(/^Join\s+([a-zA-Z_]\w*)\s+with\s+(.+)$/i);
          let listName = m[1], sep = evalExpr(m[2]);
          if (Array.isArray(vars[listName])) {
            vars[listName+"_joined"] = vars[listName].join(sep);
          }
        }
        else if (/^Concat\s+([a-zA-Z_]\w*)\s+with\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Concat\s+([a-zA-Z_]\w*)\s+with\s+([a-zA-Z_]\w*)$/i);
          let a = m[1], b = m[2];
          if (Array.isArray(vars[a]) && Array.isArray(vars[b])) {
            vars[a] = vars[a].concat(vars[b]);
          }
        }
        else if (/^Unique\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Unique\s+([a-zA-Z_]\w*)$/i);
          let listName = m[1];
          if (Array.isArray(vars[listName])) {
            vars[listName] = [...new Set(vars[listName])];
          }
        }
        else if (/^Reverse\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Reverse\s+([a-zA-Z_]\w*)$/i);
          let listName = m[1];
          if (Array.isArray(vars[listName])) {
            vars[listName].reverse();
          }
        }
        else if (/^Sort\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Sort\s+([a-zA-Z_]\w*)$/i);
          let listName = m[1];
          if (Array.isArray(vars[listName])) {
            vars[listName].sort((a, b) => (a < b ? -1 : a > b ? 1 : 0));
          }
        }
        else if (/^Slice\s+([a-zA-Z_]\w*)\s+from\s+(\d+)\s+to\s+(\d+)$/i.test(line)) {
          let m = line.match(/^Slice\s+([a-zA-Z_]\w*)\s+from\s+(\d+)\s+to\s+(\d+)$/i);
          let listName = m[1], a = parseInt(m[2])-1, b = parseInt(m[3]);
          if (Array.isArray(vars[listName])) {
            vars[listName+"_sliced"] = vars[listName].slice(a, b);
          }
        }
        else if (/^Replace\s+(.+)\s+with\s+(.+)\s+in\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Replace\s+(.+)\s+with\s+(.+)\s+in\s+([a-zA-Z_]\w*)$/i);
          let old = evalExpr(m[1]), val = evalExpr(m[2]), listName = m[3];
          if (Array.isArray(vars[listName])) {
            vars[listName] = vars[listName].map(x => x==old?val:x);
          }
        }
        else if (/^Sum\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Sum\s+([a-zA-Z_]\w*)$/i);
          let listName = m[1];
          if (Array.isArray(vars[listName])) {
            vars.sum_result = vars[listName].map(Number).reduce((a,b)=>a+b,0);
          }
        }
        else if (/^Product\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Product\s+([a-zA-Z_]\w*)$/i);
          let listName = m[1];
          if (Array.isArray(vars[listName])) {
            vars.product_result = vars[listName].map(Number).reduce((a,b)=>a*b,1);
          }
        }
        else if (/^Min\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Min\s+([a-zA-Z_]\w*)$/i);
          let listName = m[1];
          if (Array.isArray(vars[listName])) {
            vars.min_result = Math.min(...vars[listName]);
          }
        }
        else if (/^Max\s+([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Max\s+([a-zA-Z_]\w*)$/i);
          let listName = m[1];
          if (Array.isArray(vars[listName])) {
            vars.max_result = Math.max(...vars[listName]);
          }
        }
        else if (/^Index of (.+) in ([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Index of (.+) in ([a-zA-Z_]\w*)$/i);
          let val = evalExpr(m[1]), listName = m[2];
          if (Array.isArray(vars[listName])) {
            vars.index_result = vars[listName].indexOf(val)+1;
          }
        }
        else if (/^Length of ([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Length of ([a-zA-Z_]\w*)$/i);
          let listName = m[1];
          if (Array.isArray(vars[listName])) vars.length_result = vars[listName].length;
        }
        else if (/^Ask for ([a-zA-Z_]\w*)$/i.test(line)) {
          let m = line.match(/^Ask for ([a-zA-Z_]\w*)$/i);
          awaitingInput = true;
          inputVarName = m[1];
          inputCallback = function(val) {
            vars[inputVarName] = val;
            awaitingInput = false;
            runInterpreter(pc + 1);
          };
          showPromptInput();
          throw 'PAUSE_FOR_INPUT';
        }
      }

      function runInterpreter(startAt) {
        document.getElementById('output').textContent = '';
        output = '';
        try {
          for (pc = startAt || 0; pc < lines.length; pc++) {
            execLine(lines[pc]);
          }
        } catch(e) {
          if (e !== 'PAUSE_FOR_INPUT') throw e;
        }
        document.getElementById('output').textContent = output || '(no output)';
      }

      function showPromptInput() {
        let input = document.getElementById('promptInput');
        input.style.display = 'block';
        input.value = '';
        input.focus();
        input.onkeydown = function(ev) {
          if (ev.key === 'Enter') {
            let val = input.value;
            input.style.display = 'none';
            if (inputCallback) inputCallback(val);
          }
        };
      }
      runInterpreter(0);
    }
    runOrgena();
  </script>
</body>
</html>
